<!DOCTYPE html>
<html>
  <head>
    <base target="_top">
    <style>
      body { font-family: Arial, sans-serif; }
      .task { cursor: pointer; padding: 5px; border-bottom: 1px solid #ccc; }
      .selected { background-color: #80EF80; }

      .header-bar {position: sticky; top: 0; background: white; padding: 10px; border-bottom: 1px solid #ccc;}
      .filter-bar {background: white; padding: 5px;}
      .context-bar {background: white; padding: 5px;}

      .context-button {
        background-color: gray;
        color: white;
        margin: 2px;
      }

      .context-button:focus {
        background: white;
        color: black;
      }

      .context-button.selected {
        background-color: green;
        color: white; 
      }
      .priority-a {
        color: red;
      }
      .priority-b {
        color: orange;
      }
      .priority-c {
        color: green;
      }
      .priority-d {
        color: blue;
      }
      .context {
        font-size: smaller;
      }
      .complete-task {
        text-decoration: line-through;
      }
      .overdue-task {
        color: red;
      }
      .task {
        -webkit-user-select: none;  /* Safari */
        -ms-user-select: none;      /* IE 10 and IE 11 */
        user-select: none;          /* Standard syntax */
      }


      .sidebar-dialog {
        position: fixed;
        right: 0;
        top: 50%;
        width: 45%;
        height: 100vh;
        background: white;
        padding: 20px;
        box-shadow: -2px 0 10px rgba(0,0,0,0.1);
        transform: translateX(100%);
        transition: transform 0.3s ease;
      }

      .sidebar-dialog.active {
        transform: translateX(0);
      }

      .sidebar-dialog textarea, .sidebar-dialog input {
        width: 100%;
        padding: 8px;
        margin: 10px 0;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-family: Arial, sans-serif;
        font-size: 20px; 
      }

      .sidebar-dialog .buttons {
        bottom: 20px;
        width: calc(100% - 40px);
      }

      .sidebar-dialog button {
        padding: 8px 16px;
        margin: 5px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
      }

      .sidebar-dialog .confirm {
        background-color: gray;
        color: white;
      }

      .sidebar-dialog .cancel {
        background-color: gray;
        color: white;
      }

    </style>
  </head>
  <body tabindex="0">
    <h1>GooDo.txt</h1>
    <div id="dialogContainer"></div>
    <div id="headerContainer" class="header-bar">
      <div class="filter-bar">
        <button id="completeButton" onclick="cycleCompleteState()">All States</button>
        <button id="dueButton" onclick="cycleDueState()">All Dates</button>
        <button id="priorityButton" onclick="cyclePriorityState()">All Pri</button>
        <button onclick="clearFilters()">Clear Filters</button>
        <button onclick="sortTasksByDueDate()">Sort by Due Date</button>
        <button onclick="sortTasksByPriority()">Sort by Priority</button>
        <input type="text" id="searchBox" placeholder="Search..." oninput="applyFilters()">
      </div>
      <div id="contextButtons" class="context-bar">
      </div>
    </div>
    <div id="taskList"></div>
    <script>
      
      let allTasks = [];
      let lastModifiedTime = null;
      let lastSavedTime = null;
      let lastSelectedIndex = -1;
      let selectedTasks = new Set();
      let activeContexts = new Set();
      let filteredTasks = [];
      let dueState = "All Dates";
      let priorityState = "All Pri";
      let completeState = "All States";  // Can be "All States", "Complete", or "Pending"

      const saveTimeout = 3000; // You can increase this if you are getting an error that too many scripts are running on your account.  This is in milliseconds.

      function cyclePriorityState() {
        const states = ["All Pri", "(A)", "(B)", "(C)", "(D)"];
        priorityState = states[(states.indexOf(priorityState) + 1) % states.length];
        document.getElementById('priorityButton').textContent = priorityState;
        applyFilters();
      }

      function cycleCompleteState() {
        const states = ["All States", "Complete", "Pending"];
        completeState = states[(states.indexOf(completeState) + 1) % 3];
        document.getElementById('completeButton').textContent = completeState;
        applyFilters();
      }

      function cycleDueState() {
        const states = ["All Dates", "Due Today", "Due Tomorrow"];
        dueState = states[(states.indexOf(dueState) + 1) % 3];
        document.getElementById('dueButton').textContent = dueState;
        applyFilters();
      }

      function loadAllFilterSets() {
        google.script.run
          .withSuccessHandler(function(filterSets) {
            allFilterSets = filterSets || {};
          })
          .getAllFilterSets();
      }

      function loadTasks() {
        google.script.run
          .withSuccessHandler(function(result) {
            lastModifiedTime = result.lastModified;
            lastSavedTime = result.lastModified;
            displayTasks(result.tasks);
          })
          .getTasksAndModifiedTime();
      }

      function displayTasks(tasks) {
        allTasks = tasks;
        generateContextButtons();
        applyFilters();
      }

      function generateContextButtons() {
        const contextButtons = document.getElementById('contextButtons');
        const contexts = new Set();
        allTasks.forEach(task => {
          const match = task.Task.match(/ @\w+/g);
          if (match) {
            match.forEach(context => contexts.add(context.trim()));
          }
        });
        contextButtons.innerHTML = '';

        // Add "No Lists" button
        const noContextsButton = document.createElement('button');
        noContextsButton.className = 'context-button';
        noContextsButton.textContent = 'No Lists';
        noContextsButton.dataset.context = 'No Lists';
        noContextsButton.onclick = () => toggleContextFilter('No Lists');
        contextButtons.appendChild(noContextsButton);

        Array.from(contexts).sort().forEach(context => {
          const button = document.createElement('button');
          button.className = 'context-button';
          button.textContent = context;
          button.dataset.context = context;
          button.onclick = () => toggleContextFilter(context);
          contextButtons.appendChild(button);
        });
      }

      // Function to toggle context filter and update button color
      function toggleContextFilter(context) {
        const button = document.querySelector(`.context-button[data-context="${context}"]`);
        if (activeContexts.has(context)) {
          activeContexts.delete(context);
          button.classList.remove('selected');
        } else {
          activeContexts.add(context);
          button.classList.add('selected');
        }
        applyFilters();
      }

      // ... keep all existing functions the same until applyFilters ...

      function applyFilters() {
        const searchQuery = document.getElementById('searchBox').value.toLowerCase();
        const taskList = document.getElementById('taskList');
        taskList.innerHTML = '';
        
        filteredTasks = allTasks
          .map((task, originalIndex) => ({ task, originalIndex }))
          .filter(({ task }) => {
            const taskText = task.Task;
            const dueDate = taskText.match(/due:(\d{4}-\d{2}-\d{2})/)?.[1] || '';
            const today = getTodayDate();
            const tomorrow = getTomorrowDate();
            const isComplete = taskText.startsWith('x ');
            
            const matchesDue = dueState === "All Dates" || 
              (dueState === "Due Today" && dueDate === today) ||
              (dueState === "Due Tomorrow" && dueDate === tomorrow);
            
            const matchesComplete = completeState === "All States" ||
              (completeState === "Complete" && isComplete) ||
              (completeState === "Pending" && !isComplete);
            
            const matchesPriority = priorityState === "All Pri" || taskText.startsWith(priorityState);
            const matchesSearch = taskText.toLowerCase().includes(searchQuery);
            const matchesContexts = Array.from(activeContexts).length === 0 || Array.from(activeContexts).some(context => {
              if (context === 'No Lists') return !taskText.match(/ @\w+/);
              return taskText.includes(context);
            });
            
            return matchesDue && matchesComplete && matchesSearch && matchesPriority && matchesContexts;
          });

        filteredTasks.forEach(({ task, originalIndex }, filteredIndex) => {
          const div = document.createElement('div');
          div.className = 'task';
          div.dataset.taskId = task.TaskID;
          div.dataset.originalIndex = originalIndex; // Store original index
          div.dataset.filteredIndex = filteredIndex; // Store filtered index
          div.onclick = (event) => handleTaskClick(event, filteredIndex, originalIndex);

          let taskText = task.Task
            .replace(/\(A\)/g, '<span class="priority-a">(A)</span>')
            .replace(/\(B\)/g, '<span class="priority-b">(B)</span>')
            .replace(/\(C\)/g, '<span class="priority-c">(C)</span>')
            .replace(/\(D\)/g, '<span class="priority-d">(D)</span>')
            .replace(/(@\S+)/g, '<span class="context">$1</span>')
            .replace(/(r:\S+)/g, '<span class="context">$1</span>')
            .replace(/(\+\S+)/g, '<span class="context">$1</span>')
            .replace(/(last:\S+)/g, '<span class="context">$1</span>')
            .replace(/(due:\S+)/g, '<span class="context">$1</span>');

          const dueDate = taskText.substring(taskText.indexOf('due:') + 4, taskText.indexOf('due:') + 14);
          const today = getTodayDate();
          if (dueDate < today) {
            taskText = `<span class="overdue-task">${taskText}</span>`;
          }

          if (task.Task.startsWith('x ')) {
            taskText = `<span class="complete-task">${taskText}</span>`;
          }

          div.innerHTML = taskText;
          taskList.appendChild(div);
          });
        // Auto-select first task if nothing is selected
        if (lastSelectedIndex === -1 && taskList.children.length > 0) {
          const firstTask = taskList.children[0];
          firstTask.classList.add('selected');
          selectedTasks.clear();
          selectedTasks.add(0);
          lastSelectedIndex = 0;
        }
      }

      function sortTasksByDueDate() {
        allTasks.sort((a, b) => {
          const aDate = a.Task.match(/due:(\d{4}-\d{2}-\d{2})/);
          const bDate = b.Task.match(/due:(\d{4}-\d{2}-\d{2})/);
          return (aDate ? new Date(aDate[1]) : new Date(0)) - (bDate ? new Date(bDate[1]) : new Date(0));
        });
        applyFilters();
      }

      function sortTasksByPriority() {
        allTasks.sort((a, b) => {
          // Extract priorities (if they exist)
          const prioA = a.Task.match(/^\((.)\)/);
          const prioB = b.Task.match(/^\((.)\)/);
          
          // Handle cases where one or both tasks don't have priorities
          if (!prioA && !prioB) return 0;
          if (!prioA) return 1;
          if (!prioB) return -1;
          
          return prioA[1].localeCompare(prioB[1]);
        });
        applyFilters();
      }

      function copySelectedTasks() {
        const taskList = document.getElementById('taskList');
        const tasks = taskList.getElementsByClassName('task');
        const selectedText = Array.from(selectedTasks)
          .sort((a, b) => a - b)
          .map(index => tasks[index].textContent)
          .join('\n');
		    navigator.clipboard.writeText(selectedText);
      };
    
      function saveFilterSet(number) {
        const filterSet = {
          dueState: dueState,
          priorityState: priorityState,
          completeState: completeState,
          searchQuery: document.getElementById('searchBox').value,
          activeContexts: Array.from(activeContexts)
        };
        allFilterSets[number] = filterSet;  // Save to memory
        
        // Save all filter sets to a single file
        google.script.run.saveAllFilterSets(allFilterSets);
        
        const htmlContent = `
          <h2>Filter set saved.</h2>
          <input type="hidden" value="copy">
          <div class="buttons">
            <button class="confirm" autofocus>OK</button>
            <button class="cancel" style="display: none;">Cancel</button>
          </div>
        `;
        showDialog(htmlContent, () => {});
      }

      function loadFilterSet(number) {
        const filterSet = allFilterSets[number];
        if (filterSet) {
          applyLoadedFilterSet(filterSet);
        }
      }

      function applyLoadedFilterSet(filterSet) {
        clearFilters();
        dueState = filterSet.dueState || "All Dates";
        priorityState = filterSet.priorityState || "All Pri";
        completeState = filterSet.completeState || "All States";
        activeContexts = new Set(filterSet.activeContexts);
        
        document.getElementById('dueButton').textContent = dueState;
        document.getElementById('priorityButton').textContent = priorityState;
        document.getElementById('completeButton').textContent = completeState;
        document.getElementById('searchBox').value = filterSet.searchQuery;
        
        applyFilters();
      }

      function clearFilters() {
        dueState = "All Dates";
        priorityState = "All Pri";
        completeState = "All States";
        document.getElementById('dueButton').textContent = "All Dates";
        document.getElementById('priorityButton').textContent = "All Pri";
        document.getElementById('completeButton').textContent = "All States";
        document.getElementById('searchBox').value = '';
        const contextButtons = document.getElementsByClassName('context-button');
        Array.from(contextButtons).forEach(button => {
          button.classList.remove('selected');
        });
        activeContexts.clear();
        applyFilters();
      }

      function swapTasks(filteredIndex1, filteredIndex2) {
        // Get the original indices from the filtered tasks
        const originalIndex1 = filteredTasks[filteredIndex1].originalIndex;
        const originalIndex2 = filteredTasks[filteredIndex2].originalIndex;

        // Swap in the allTasks array
        const tempTask = allTasks[originalIndex1];
        allTasks[originalIndex1] = allTasks[originalIndex2];
        allTasks[originalIndex2] = tempTask;

        // Update TaskIDs
        allTasks[originalIndex1].TaskID = originalIndex1;
        allTasks[originalIndex2].TaskID = originalIndex2;

        // Reapply filters to update the display
        applyFilters();

        // Update selection to follow the moved task
        const taskList = document.getElementById('taskList');
        const tasks = taskList.getElementsByClassName('task');
        Array.from(tasks).forEach(task => task.classList.remove('selected'));
        
        // Find the new filtered index of the moved task
        const newFilteredIndex = filteredTasks.findIndex(t => t.originalIndex === originalIndex2);
        if (newFilteredIndex !== -1) {
          tasks[newFilteredIndex].classList.add('selected');
          selectedTasks.clear();
          selectedTasks.add(newFilteredIndex);
          lastSelectedIndex = newFilteredIndex;
        }
      }


      // Function to get today's date in user's local time zone in YYYY-MM-DD format
      function getTodayDate() {
        const today = new Date();
        return today.toLocaleDateString('en-CA'); // 'en-CA' locale for YYYY-MM-DD format
      }

      // Function to get tomorrow's date in user's local time zone in YYYY-MM-DD format
      function getTomorrowDate() {
        const tomorrow = new Date();
        tomorrow.setDate(tomorrow.getDate() + 1);
        return tomorrow.toLocaleDateString('en-CA');
      }

      // Function to get the date for the next occurrence of a day of the week in user's local time zone
      function getNextDayOfWeekDate(dayOfWeek) {
        const daysOfWeek = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
        const today = new Date();
        const todayDayOfWeek = today.getDay();
        const targetDayOfWeek = daysOfWeek.findIndex(day => day.toLowerCase() === dayOfWeek.toLowerCase());
        const daysUntilNext = (targetDayOfWeek + 7 - todayDayOfWeek) % 7 || 7;
        today.setDate(today.getDate() + daysUntilNext);
        return today.toLocaleDateString('en-CA');
      }

      // Function to replace due date keywords with actual dates in user's local time zone
      function replaceDueDateKeywords(task) {
        return task.replace(/due:today/gi, `due:${getTodayDate()}`)
                  .replace(/due:tomorrow/gi, `due:${getTomorrowDate()}`)
                  .replace(/due:(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/gi, (match, day) => `due:${getNextDayOfWeekDate(day)}`);
      }

      function toggleCompletion(selectedTasks) {
      const todayDate = getTodayDate();
      selectedTasks.forEach(task => {
        if (task.Task.startsWith('x ')) {
          task.Task = task.Task.replace(/^x \d{4}-\d{2}-\d{2} /, '');
        } else {
          task.Task = `x ${todayDate} ${task.Task}`;
        }
      });
      }

      // Function to open a popup window with a custom dialog
      function showPopupDialog(htmlContent, callback) {
        const popup = window.open('', 'popup', 'width=400,height=300');
        popup.document.write(htmlContent);
        popup.document.close();
        const textarea = popup.document.querySelector('textarea');
        if (textarea) {
          textarea.focus();
        }
        popup.document.querySelector('.confirm').onclick = () => {
          const input = popup.document.querySelector('input, textarea').value;
          callback(input);
          popup.close();
        };
        popup.document.querySelector('.cancel').onclick = () => {
          callback(false);
          popup.close();
        };
      }

      function editTask(index) {
        const task = allTasks[index];
        const htmlContent = `
          <h2>Edit Task</h2>
          <textarea autofocus>${task.Task}</textarea>
          <div class="buttons">
            <button class="confirm">Save</button>
            <button class="cancel">Cancel</button>
          </div>
        `;
        showDialog(htmlContent, (newTask) => {
          if (newTask !== null) {
            allTasks[index].Task = replaceDueDateKeywords(newTask);
            applyFilters();
          }
        });
      }
	  
	    function addNewTask() {
        const htmlContent = `
          <h2>New Task</h2>
          <textarea placeholder="Enter the new task" autofocus></textarea>
          <div class="buttons">
            <button class="confirm">Add</button>
            <button class="cancel">Cancel</button>
          </div>
          `;
        showDialog(htmlContent, (newTask) => {
          if (newTask) {
            allTasks.unshift({ TaskID: allTasks.length, Task: replaceDueDateKeywords(newTask) });
            applyFilters();
          }
        });
      }

      function setDateForSelectedTasks() {
        const htmlContent = `
          <h2>Set Due Date</h2>
          <input type="text" placeholder="Enter the new date (YYYY-MM-DD, today, tomorrow, or day of the week)">
          <div class="buttons">
            <button class="confirm">Set Date</button>
            <button class="cancel">Cancel</button>
          </div>
        `;
        showDialog(htmlContent, (newDate) => {
          if (newDate) {
            const originalIndices = getOriginalIndices();
            const formattedDate = replaceDueDateKeywords(`due:${newDate}`).split('due:')[1];
            originalIndices.forEach(index => {
              allTasks[index].Task = allTasks[index].Task.replace(/due:\d{4}-\d{2}-\d{2}/, `due:${formattedDate}`);
            });
            applyFilters();
          }
        });
      }

      function deleteTask(index) {
        const task = allTasks[index];
        const htmlContent = `
          <h2>Delete Task(s)</h2>
          <input type=hidden value="delete">
          <p>Are you sure?</p>
          <div class="buttons">
            <button class="confirm" data-confirmed="true">Delete</button>
            <button class="cancel" data-confirmed="false">Cancel</button>
          </div>
        `;
        showDialog(htmlContent, (confirmed) => {
          if (confirmed) {
            const originalIndices = getOriginalIndices().sort((a, b) => b - a);  // Sort in reverse order
            originalIndices.forEach(idx => {
              allTasks.splice(idx, 1);
            });
            applyFilters();
          }
        });
      }

      function changePriority(tasks, increase) {
      const priorities = ['A', 'B', 'C', 'D'];

      tasks.forEach(task => {
        if (!task.Task.startsWith('(')) return;
        
        const currentPriority = task.Task[1];
        const currentIndex = priorities.indexOf(currentPriority);
        
        if (currentIndex === -1) return;
        
        let newIndex = increase ? 
          Math.max(0, currentIndex - 1) : 
          Math.min(priorities.length - 1, currentIndex + 1);
          
        task.Task = `(${priorities[newIndex]})${task.Task.slice(3)}`;
      });
      }

      function setPriorityForSelectedTasks() {
        const htmlContent = `
          <h2>Set Priority</h2>
          <input type="text" placeholder="Enter the new priority (A, B, C, etc.)">
          <div class="buttons">
            <button class="confirm">Set Priority</button>
            <button class="cancel">Cancel</button>
          </div>
        `;
        showDialog(htmlContent, (newPriority) => {
          if (newPriority) {
            const originalIndices = getOriginalIndices();
            originalIndices.forEach(index => {
              allTasks[index].Task = allTasks[index].Task.replace(/^\(.\)/, `(${newPriority})`);
            });
            applyFilters();
          }
        });
      }

      // Function to postpone selected tasks
      function postponeSelectedTasks() {
        const htmlContent = `
        <h2>Postpone</h2>
        <input type="number" placeholder="Enter the number of days to postpone">
        <div class="buttons">
            <button class="confirm">Postpone</button>
            <button class="cancel">Cancel</button>
          </div>
        `;
        showDialog(htmlContent, (days) => {
          if (days) {
			      const originalIndices = getOriginalIndices();
            originalIndices.forEach(index => {
              const task = allTasks[index];
              const dueDateMatch = task.Task.match(/due:(\d{4}-\d{2}-\d{2})/);
              if (dueDateMatch) {
                const dueDate = new Date(dueDateMatch[1]);
                dueDate.setDate(dueDate.getDate() + parseInt(days));
                const newDueDate = dueDate.toISOString().split('T')[0];
                allTasks[index].Task = task.Task.replace(/due:\d{4}-\d{2}-\d{2}/, `due:${newDueDate}`);
              }
            });
            applyFilters();
          }
        });
      }

      function showDialog(htmlContent, callback) {
        const dialogContainer = document.getElementById('dialogContainer');
        dialogContainer.innerHTML = `
          <div class="sidebar-dialog">
            ${htmlContent}
          </div>
        `;
          
        const dialog = dialogContainer.querySelector('.sidebar-dialog');
        setTimeout(() => dialog.classList.add('active'), 10); // Trigger animation

        const input = dialog.querySelector('input:not([type="hidden"]), textarea');
        const confirmButton = dialog.querySelector('.confirm');

        // Focus on input if it exists and is visible, otherwise focus on confirm button
        if (input && input.type !== 'hidden' && window.getComputedStyle(input).display !== 'none') {
          input.focus();
          input.addEventListener('keydown', (e) => {
            e.stopPropagation();
          });
        } else if (confirmButton) {
          setTimeout(() => confirmButton.focus(), 50);
        }

        // Add click handler for the dialog container
        const handleOutsideClick = (e) => {
          if (!dialog.contains(e.target)) {
            closeDialog();
          }
        };

        const closeDialog = () => {
          dialog.classList.remove('active');
          setTimeout(() => {
            callback(null);
            dialogContainer.innerHTML = '';
            document.removeEventListener('click', handleOutsideClick);
          }, 300);
        };

        dialog.querySelector('.confirm').onclick = () => {
          const input = dialog.querySelector('input, textarea');
          dialog.classList.remove('active');
          setTimeout(() => {
            callback(input.value);
            dialogContainer.innerHTML = '';
            document.removeEventListener('click', handleOutsideClick);
          }, 300);
        };

        dialog.querySelector('.cancel').onclick = () => {
          closeDialog();
        };

        setTimeout(() => {
          document.addEventListener('click', handleOutsideClick);
        }, 100);
      }

      function getOriginalIndices() {
        const taskList = document.getElementById('taskList');
        const tasks = taskList.getElementsByClassName('task');
        return Array.from(selectedTasks).map(index => parseInt(tasks[index].dataset.originalIndex));
      }

      // automatically save waiting for 'saveTimeout' milliseconds
      let timeoutId;
      // Function to listen for keyboard input
      function listenForKeyboardInput() {
        document.addEventListener('keydown', resetTimer);
      }
      // Function to reset the timer
      function resetTimer() {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(saveTasks, saveTimeout);
      }

      function checkFileModified() {
        return new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(function(currentModifiedTime) {
              if (currentModifiedTime !== lastModifiedTime) {
                const htmlContent = `
                  <h2>Warning: File Modified</h2>
                  <p>The task file has been modified externally since it was last loaded.</p>
                  <p>Do you want to:</p>
                  <div class="buttons">
                    <button class="confirm">Save Anyway</button>
                    <button class="cancel">Cancel Save</button>
                  </div>
                `;
                showDialog(htmlContent, (confirmed) => {
                  resolve(confirmed === null ? false : true);
                });
              } else {
                resolve(true);
              }
            })
            .withFailureHandler(function(error) {
              reject(error);
            })
            .getLastModifiedTime();
        });
      }

      // Function to save all tasks to a text file
      async function saveTasks() {
        try {
          const canSave = await checkFileModified();
          if (canSave) {
            const allTasksText = allTasks.map(task => task.Task).join('\n');
            google.script.run
              .withSuccessHandler(function(newModifiedTime) {
                lastModifiedTime = newModifiedTime;
                lastSavedTime = newModifiedTime;
              })
              .saveTasksToFile(allTasksText);
          } else {
            // Optionally reload the file here if user cancels
            loadTasks();
          }
        } catch (error) {
          const htmlContent = `
            <h2>Error</h2>
            <p>Failed to check file status: ${error}</p>
            <div class="buttons">
              <button class="confirm">OK</button>
              <button class="cancel" style="display: none;">Cancel</button>
            </div>
          `;
          showDialog(htmlContent, () => {});
        }
      }

      function handleTaskClick(event, index) {
        const taskList = document.getElementById('taskList');
        const tasks = taskList.getElementsByClassName('task');
        const originalIndex = parseInt(tasks[index].dataset.originalIndex);

        if (event.detail === 2) {
          editTask(originalIndex);
        } else {
          if (event.ctrlKey) {
            tasks[index].classList.toggle('selected');
            if (selectedTasks.has(index)) {
              selectedTasks.delete(index);
            } else {
              selectedTasks.add(index);
            }
          } else if (event.shiftKey && lastSelectedIndex !== -1) {
            const start = Math.min(lastSelectedIndex, index);
            const end = Math.max(lastSelectedIndex, index);
            for (let i = start; i <= end; i++) {
              tasks[i].classList.add('selected');
              selectedTasks.add(i);
            }
          } else {
            Array.from(tasks).forEach(task => task.classList.remove('selected'));
            tasks[index].classList.add('selected');
            selectedTasks.clear();
            selectedTasks.add(index);
          }
          lastSelectedIndex = index;
        }
      }

      function handleKeyDown(event) {
        // Ignore hotkeys if search box is focused or dialog box is open
        if (document.activeElement === document.getElementById('searchBox') || document.getElementById('dialogContainer').innerHTML !== '') {
          return;
        }
        const taskList = document.getElementById('taskList');
        const tasks = taskList.getElementsByClassName('task');
        if (lastSelectedIndex === -1) return;

        if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {
          const taskList = document.getElementById('taskList');
          const tasks = taskList.getElementsByClassName('task');
          const selectedTask = tasks[lastSelectedIndex];
          
          if (selectedTask) {
            const rect = selectedTask.getBoundingClientRect();
            const viewHeight = window.innerHeight;
            
            // Get distance from top/bottom of viewport in number of tasks
            const tasksFromTop = Math.floor(rect.top / rect.height);
            const tasksFromBottom = Math.floor((viewHeight - rect.bottom) / rect.height);
            
            // Only prevent default scrolling if we're not near the edges
            if (event.key === 'ArrowUp' && tasksFromTop > 5 || 
                event.key === 'ArrowDown' && tasksFromBottom > 5) {
              event.preventDefault();
            }
          }

          if (event.key === 'ArrowUp') {
            if (event.ctrlKey && lastSelectedIndex > 0) {
              swapTasks(lastSelectedIndex, lastSelectedIndex - 1);
            } else if (event.altKey) {
              const selectedTaskObjects = getOriginalIndices().map(i => allTasks[i]);
              changePriority(selectedTaskObjects, true);
              applyFilters();
              const taskList = document.getElementById('taskList');
              const tasks = taskList.getElementsByClassName('task');
              selectedTasks.forEach(index => {
                tasks[index].classList.add('selected');
              });
            } else if (lastSelectedIndex > 0) {
              if (event.shiftKey) {
                // If shift is pressed, toggle selection of the previous task
                const newIndex = lastSelectedIndex - 1;
                if (selectedTasks.has(newIndex)) {
                  tasks[lastSelectedIndex].classList.remove('selected');
                  selectedTasks.delete(lastSelectedIndex);
                } else {
                  tasks[newIndex].classList.add('selected');
                  selectedTasks.add(newIndex);
                }
                lastSelectedIndex = newIndex;
              } else {
                // If no shift, clear all selections and select only the new task
                Array.from(tasks).forEach(task => task.classList.remove('selected'));
                lastSelectedIndex--;
                tasks[lastSelectedIndex].classList.add('selected');
                selectedTasks.clear();
                selectedTasks.add(lastSelectedIndex);
              }
            }
          } else if (event.key === 'ArrowDown') {
            if (event.ctrlKey && lastSelectedIndex < tasks.length - 1) {
              swapTasks(lastSelectedIndex, lastSelectedIndex + 1);
            } else if (event.altKey) {
              const selectedTaskObjects = getOriginalIndices().map(i => allTasks[i]);
              changePriority(selectedTaskObjects, false);
              applyFilters();
              const taskList = document.getElementById('taskList');
              const tasks = taskList.getElementsByClassName('task');
              selectedTasks.forEach(index => {
                tasks[index].classList.add('selected');
              });
            } else if (lastSelectedIndex < tasks.length - 1) {
              if (event.shiftKey) {
                // If shift is pressed, toggle selection of the next task
                const newIndex = lastSelectedIndex + 1;
                if (selectedTasks.has(newIndex)) {
                  tasks[lastSelectedIndex].classList.remove('selected');
                  selectedTasks.delete(lastSelectedIndex);
                } else {
                  tasks[newIndex].classList.add('selected');
                  selectedTasks.add(newIndex);
                }
                lastSelectedIndex = newIndex;
              } else {
                // If no shift, clear all selections and select only the new task
                Array.from(tasks).forEach(task => task.classList.remove('selected'));
                lastSelectedIndex++;
                tasks[lastSelectedIndex].classList.add('selected');
                selectedTasks.clear();
                selectedTasks.add(lastSelectedIndex);
              }
            }
          }
        } else if (event.key === ' ') {
          event.preventDefault();
          const selectedTask = tasks[lastSelectedIndex];
          if (selectedTask) {
            const originalIndex = parseInt(selectedTask.dataset.originalIndex);
            editTask(originalIndex);
          }
        } else if (event.key === 'c' && event.ctrlKey) {
          copySelectedTasks();
        } else if (event.key === 'c' && !event.ctrlKey) {
          cycleCompleteState();
        } else if (event.ctrlKey && event.altKey && event.key >= '1' && event.key <= '9') {
          saveFilterSet(event.key);
        } else if (event.key >= '1' && event.key <= '9') {
          loadFilterSet(event.key);
        } else if (event.key === 'x') {
          const selectedTaskObjects = getOriginalIndices().map(i => allTasks[i]);
          toggleCompletion(selectedTaskObjects);
          applyFilters();
          const taskList = document.getElementById('taskList');
          const tasks = taskList.getElementsByClassName('task');
          selectedTasks.forEach(index => {
            tasks[index].classList.add('selected');
          });
        } else if (event.key === 'd') {
          event.preventDefault();
          deleteTask(filteredTasks[lastSelectedIndex].originalIndex);
        } else if (event.ctrlKey && event.key === 'f') {
          event.preventDefault();
          document.getElementById('searchBox').focus();
          return;
        } else if (event.key === 'q') {
          event.preventDefault();
          cyclePriorityState();
        } else if (event.key === 'n') {
          event.preventDefault();
          addNewTask();
        } else if (!event.ctrlKey && event.key === 'r') {
          event.preventDefault();
          sortTasksByPriority();
        } else if (event.key === 's') {
          event.preventDefault();
          setDateForSelectedTasks();
        } else if (event.key === 't') {
          event.preventDefault();
          sortTasksByDueDate();
        } else if (event.key === 'i') {
          event.preventDefault();
          setPriorityForSelectedTasks();
        } else if (event.key === 'p') {
          event.preventDefault();
          postponeSelectedTasks();
        } else if (event.key === 'u') {
          event.preventDefault();
          cycleDueState();
        } else if (event.key === '0') {
          event.preventDefault();
          clearFilters();
        }
      }

      // Start listening for keyboard input
      listenForKeyboardInput();

      document.addEventListener('DOMContentLoaded', function() {
        loadTasks();
        loadAllFilterSets();
      });
      document.addEventListener('keydown', handleKeyDown);
	  
	    // Add this line to focus the page on load
	    window.onload = () => document.body.focus();
	  
    </script>
  </body>
</html>
