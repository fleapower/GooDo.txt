<!DOCTYPE html>
<html>
  <head>
    <base target="_top">
    <style>
      body { font-family: Arial, sans-serif; }
      .task { cursor: pointer; padding: 5px; border-bottom: 1px solid #ccc; }
      .selected { background-color: #80EF80; }
      .filter-bar { position: sticky; top: 0; background: white; padding: 10px; border-bottom: 1px solid #ccc; }
      .tag-button {
        background-color: gray;
        color: white;
        margin: 2px;
      }
      .tag-button.selected {
        background-color: green;
      }
      .priority-a {
        color: red;
      }
      .priority-b {
        color: orange;
      }
      .priority-c {
        color: green;
      }
      .priority-d {
        color: blue;
      }
      .tag {
        font-size: smaller;
      }
      .completed-task {
        text-decoration: line-through;
      }
      .overdue-task {
        color: red;
      }
      .task {
        -webkit-user-select: none;  /* Safari */
        -ms-user-select: none;      /* IE 10 and IE 11 */
        user-select: none;          /* Standard syntax */
      }


      .sidebar-dialog {
        position: fixed;
        right: 0;
        top: 50%;
        width: 45%;
        height: 100vh;
        background: white;
        padding: 20px;
        box-shadow: -2px 0 10px rgba(0,0,0,0.1);
        transform: translateX(100%);
        transition: transform 0.3s ease;
      }

      .sidebar-dialog.active {
        transform: translateX(0);
      }

      .sidebar-dialog textarea, .sidebar-dialog input {
        width: 100%;
        padding: 8px;
        margin: 10px 0;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-family: Arial, sans-serif;
        font-size: 20px; 
      }

      .sidebar-dialog .buttons {
        bottom: 20px;
        width: calc(100% - 40px);
      }

      .sidebar-dialog button {
        padding: 8px 16px;
        margin: 5px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
      }

      .sidebar-dialog .confirm {
        background-color: gray;
        color: white;
      }

      .sidebar-dialog .cancel {
        background-color: gray;
        color: white;
      }

    </style>
  </head>
  <body tabindex="0">
    <!-- ... existing HTML remains the same ... -->
    <h1>GooDo.txt</h1>
    <div id="dialogContainer"></div>
    <div class="filter-bar">
      <input type="checkbox" id="dueToday" onclick="applyFilters()"> Due Today
      <input type="text" id="searchBox" placeholder="Search..." oninput="applyFilters()">
      <select id="priorityFilter" onchange="applyFilters()">
        <option value="all">All</option>
        <!-- Dynamically populated priorities -->
      </select>
      <button onclick="clearFilters()">Clear Filters</button>
      <button onclick="sortTasksByDueDate()">Sort by Due Date</button>
    </div>
    <div id="tagButtons" class="filter-bar"></div>
    <div id="taskList"></div>
    <script>
      let allTasks = [];
      let lastSelectedIndex = -1;
      let selectedTasks = new Set();
      let activeTags = new Set();
      let filteredTasks = []; // Add this to track filtered tasks

      const saveTimeout = 3000;

      function loadTasks() {
        google.script.run.withSuccessHandler(displayTasks).getTasks();
      }

      function displayTasks(tasks) {
        allTasks = tasks;
        populatePriorityFilter();
        generateTagButtons();
        applyFilters();
      }

      function populatePriorityFilter() {
        const priorityFilter = document.getElementById('priorityFilter');
        const priorities = new Set();
        allTasks.forEach(task => {
          const match = task.Task.match(/^\((.)\)/);
          if (match) {
            priorities.add(match[0]);
          } else if (task.Task.startsWith('x')) {
            priorities.add('x');
          }
        });
        Array.from(priorities).sort().forEach(priority => {
          const option = document.createElement('option');
          option.value = priority;
          option.textContent = priority;
          priorityFilter.appendChild(option);
        });
      }

      function generateTagButtons() {
        const tagButtons = document.getElementById('tagButtons');
        const tags = new Set();
        allTasks.forEach(task => {
          const match = task.Task.match(/ @\w+/g);
          if (match) {
            match.forEach(tag => tags.add(tag.trim()));
          }
        });
        tagButtons.innerHTML = '';

        // Add "No Lists" button
        const noTagsButton = document.createElement('button');
        noTagsButton.className = 'tag-button';
        noTagsButton.textContent = 'No Lists';
        noTagsButton.dataset.tag = 'No Lists';
        noTagsButton.onclick = () => toggleTagFilter('No Lists');
        tagButtons.appendChild(noTagsButton);

        Array.from(tags).sort().forEach(tag => {
          const button = document.createElement('button');
          button.className = 'tag-button';
          button.textContent = tag;
          button.dataset.tag = tag;
          button.onclick = () => toggleTagFilter(tag);
          tagButtons.appendChild(button);
        });
      }

      // Function to toggle tag filter and update button color
      function toggleTagFilter(tag) {
        const button = document.querySelector(`.tag-button[data-tag="${tag}"]`);
        if (activeTags.has(tag)) {
          activeTags.delete(tag);
          button.classList.remove('selected');
        } else {
          activeTags.add(tag);
          button.classList.add('selected');
        }
        applyFilters();
      }

      // ... keep all existing functions the same until applyFilters ...

      function applyFilters() {
        const dueToday = document.getElementById('dueToday').checked;
        const searchQuery = document.getElementById('searchBox').value.toLowerCase();
        const priorityFilter = document.getElementById('priorityFilter').value;
        const taskList = document.getElementById('taskList');
        taskList.innerHTML = '';
        
        // Store filtered tasks with their original indices
        filteredTasks = allTasks
          .map((task, originalIndex) => ({ task, originalIndex }))
          .filter(({ task }) => {
            const taskText = task.Task;
            const dueDate = taskText.substring(taskText.indexOf('due:') + 4, taskText.indexOf('due:') + 14);
            const today = getTodayDate();
            const matchesDueToday = !dueToday || (dueDate <= today);
            const matchesSearch = taskText.toLowerCase().includes(searchQuery);
            const matchesPriority = priorityFilter === 'all' || taskText.startsWith(priorityFilter);
            const matchesTags = Array.from(activeTags).length === 0 || Array.from(activeTags).some(tag => {
              if (tag === 'No Lists') {
                return !taskText.match(/ @\w+/);
              }
              return taskText.includes(tag);
            });
            return matchesDueToday && matchesSearch && matchesPriority && matchesTags;
          });

        filteredTasks.forEach(({ task, originalIndex }, filteredIndex) => {
          const div = document.createElement('div');
          div.className = 'task';
          div.dataset.taskId = task.TaskID;
          div.dataset.originalIndex = originalIndex; // Store original index
          div.dataset.filteredIndex = filteredIndex; // Store filtered index
          div.onclick = (event) => handleTaskClick(event, filteredIndex, originalIndex);

          let taskText = task.Task
            .replace(/\(A\)/g, '<span class="priority-a">(A)</span>')
            .replace(/\(B\)/g, '<span class="priority-b">(B)</span>')
            .replace(/\(C\)/g, '<span class="priority-c">(C)</span>')
            .replace(/\(D\)/g, '<span class="priority-d">(D)</span>')
            .replace(/(@\S+)/g, '<span class="tag">$1</span>')
            .replace(/(r:\S+)/g, '<span class="tag">$1</span>')
            .replace(/(\+\S+)/g, '<span class="tag">$1</span>')
            .replace(/(last:\S+)/g, '<span class="tag">$1</span>')
            .replace(/(due:\S+)/g, '<span class="tag">$1</span>');

          const dueDate = taskText.substring(taskText.indexOf('due:') + 4, taskText.indexOf('due:') + 14);
          const today = getTodayDate();
          if (dueDate < today) {
            taskText = `<span class="overdue-task">${taskText}</span>`;
          }

          if (task.Task.startsWith('x ')) {
            taskText = `<span class="completed-task">${taskText}</span>`;
          }

          div.innerHTML = taskText;
          taskList.appendChild(div);
          });
        // Auto-select first task if nothing is selected
        if (lastSelectedIndex === -1 && taskList.children.length > 0) {
          const firstTask = taskList.children[0];
          firstTask.classList.add('selected');
          selectedTasks.clear();
          selectedTasks.add(0);
          lastSelectedIndex = 0;
        }
      }

      function clearFilters() {
        document.getElementById('dueToday').checked = false;
        document.getElementById('searchBox').value = '';
        document.getElementById('priorityFilter').value = 'all';
    
        // Reset tag buttons visual state
        const tagButtons = document.getElementsByClassName('tag-button');
        Array.from(tagButtons).forEach(button => {
          button.classList.remove('selected');
        });
        activeTags.clear();
        applyFilters();
      }

      function sortTasksByDueDate() {
        allTasks.sort((a, b) => {
          const aDate = a.Task.match(/due:(\d{4}-\d{2}-\d{2})/);
          const bDate = b.Task.match(/due:(\d{4}-\d{2}-\d{2})/);
          return (aDate ? new Date(aDate[1]) : new Date(0)) - (bDate ? new Date(bDate[1]) : new Date(0));
        });
        applyFilters();
      }

      function copySelectedTasks() {
        const taskList = document.getElementById('taskList');
        const tasks = taskList.getElementsByClassName('task');
        const selectedText = Array.from(selectedTasks)
          .sort((a, b) => a - b)
          .map(index => tasks[index].textContent)
          .join('\n');
		    navigator.clipboard.writeText(selectedText);
      };
	  

    
      function saveFilterSet(number) {
        const filterSet = {
          dueToday: document.getElementById('dueToday').checked,
          searchQuery: document.getElementById('searchBox').value,
          priorityFilter: document.getElementById('priorityFilter').value,
          activeTags: Array.from(activeTags)
        };
        google.script.run.saveFilterSet(number, filterSet);
        const htmlContent = `
		    	<h2>Filter saved.</h2>
			    <input type=hidden value="copy">
          <div class="buttons">
			    	<button class="confirm" autofocus>OK</button>
            <button class="cancel" style="display: none;">Cancel</button>
          </div>
        `;
        showDialog(htmlContent, (confirm) => {
        });
      }

      function loadFilterSet(number) {
        google.script.run.withSuccessHandler(applyLoadedFilterSet).loadFilterSet(number);
      }

      function applyLoadedFilterSet(filterSet) {

        document.getElementById('dueToday').checked = filterSet.dueToday;
        document.getElementById('searchBox').value = filterSet.searchQuery;
        document.getElementById('priorityFilter').value = filterSet.priorityFilter;
        activeTags = new Set(filterSet.activeTags);
        applyFilters();
      }

      function swapTasks(filteredIndex1, filteredIndex2) {
        // Get the original indices from the filtered tasks
        const originalIndex1 = filteredTasks[filteredIndex1].originalIndex;
        const originalIndex2 = filteredTasks[filteredIndex2].originalIndex;

        // Swap in the allTasks array
        const tempTask = allTasks[originalIndex1];
        allTasks[originalIndex1] = allTasks[originalIndex2];
        allTasks[originalIndex2] = tempTask;

        // Update TaskIDs
        allTasks[originalIndex1].TaskID = originalIndex1;
        allTasks[originalIndex2].TaskID = originalIndex2;

        // Reapply filters to update the display
        applyFilters();

        // Update selection to follow the moved task
        const taskList = document.getElementById('taskList');
        const tasks = taskList.getElementsByClassName('task');
        Array.from(tasks).forEach(task => task.classList.remove('selected'));
        
        // Find the new filtered index of the moved task
        const newFilteredIndex = filteredTasks.findIndex(t => t.originalIndex === originalIndex2);
        if (newFilteredIndex !== -1) {
          tasks[newFilteredIndex].classList.add('selected');
          selectedTasks.clear();
          selectedTasks.add(newFilteredIndex);
          lastSelectedIndex = newFilteredIndex;
        }
      }


      // Function to get today's date in user's local time zone in YYYY-MM-DD format
      function getTodayDate() {
        const today = new Date();
        return today.toLocaleDateString('en-CA'); // 'en-CA' locale for YYYY-MM-DD format
      }

      // Function to get tomorrow's date in user's local time zone in YYYY-MM-DD format
      function getTomorrowDate() {
        const tomorrow = new Date();
        tomorrow.setDate(tomorrow.getDate() + 1);
        return tomorrow.toLocaleDateString('en-CA');
      }

      // Function to get the date for the next occurrence of a day of the week in user's local time zone
      function getNextDayOfWeekDate(dayOfWeek) {
        const daysOfWeek = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
        const today = new Date();
        const todayDayOfWeek = today.getDay();
        const targetDayOfWeek = daysOfWeek.findIndex(day => day.toLowerCase() === dayOfWeek.toLowerCase());
        const daysUntilNext = (targetDayOfWeek + 7 - todayDayOfWeek) % 7 || 7;
        today.setDate(today.getDate() + daysUntilNext);
        return today.toLocaleDateString('en-CA');
      }

      // Function to replace due date keywords with actual dates in user's local time zone
      function replaceDueDateKeywords(task) {
        return task.replace(/due:today/gi, `due:${getTodayDate()}`)
                  .replace(/due:tomorrow/gi, `due:${getTomorrowDate()}`)
                  .replace(/due:(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/gi, (match, day) => `due:${getNextDayOfWeekDate(day)}`);
      }

      function toggleCompletion(selectedTasks) {
      const todayDate = getTodayDate();
      selectedTasks.forEach(task => {
        if (task.Task.startsWith('x ')) {
          task.Task = task.Task.replace(/^x \d{4}-\d{2}-\d{2} /, '');
        } else {
          task.Task = `x ${todayDate} ${task.Task}`;
        }
      });
      }

      // Function to open a popup window with a custom dialog
      function showPopupDialog(htmlContent, callback) {
        const popup = window.open('', 'popup', 'width=400,height=300');
        popup.document.write(htmlContent);
        popup.document.close();
        const textarea = popup.document.querySelector('textarea');
        if (textarea) {
          textarea.focus();
        }
        popup.document.querySelector('.confirm').onclick = () => {
          const input = popup.document.querySelector('input, textarea').value;
          callback(input);
          popup.close();
        };
        popup.document.querySelector('.cancel').onclick = () => {
          callback(false);
          popup.close();
        };
      }
	  
      // Function to edit a task

      function editTask(index) {
        const task = allTasks[index];
        const htmlContent = `
          <h2>Edit Task</h2>
          <textarea autofocus>${task.Task}</textarea>
          <div class="buttons">
            <button class="confirm">Save</button>
            <button class="cancel">Cancel</button>
          </div>
        `;
        showDialog(htmlContent, (newTask) => {
          if (newTask !== null) {
            allTasks[index].Task = replaceDueDateKeywords(newTask);
            applyFilters();
          }
        });
      }
	  
	    function addNewTask() {
        const htmlContent = `
          <h2>New Task</h2>
          <textarea placeholder="Enter the new task" autofocus></textarea>
          <div class="buttons">
            <button class="confirm">Add</button>
            <button class="cancel">Cancel</button>
          </div>
          `;
        showDialog(htmlContent, (newTask) => {
          if (newTask) {
            allTasks.unshift({ TaskID: allTasks.length, Task: replaceDueDateKeywords(newTask) });
            applyFilters();
          }
        });
      }

      function setDateForSelectedTasks() {
        const htmlContent = `
          <h2>Set Due Date</h2>
          <input type="text" placeholder="Enter the new date (YYYY-MM-DD, today, tomorrow, or day of the week)">
          <div class="buttons">
            <button class="confirm">Set Date</button>
            <button class="cancel">Cancel</button>
          </div>
        `;
        showDialog(htmlContent, (newDate) => {
          if (newDate) {
            const originalIndices = getOriginalIndices();
            const formattedDate = replaceDueDateKeywords(`due:${newDate}`).split('due:')[1];
            originalIndices.forEach(index => {
              allTasks[index].Task = allTasks[index].Task.replace(/due:\d{4}-\d{2}-\d{2}/, `due:${formattedDate}`);
            });
            applyFilters();
          }
        });
      }

/*
  		function setPriorityForSelectedTasks() {
        const htmlContent = `
          <h2>Set Priority</h2>
          <input type="text" placeholder="Enter the new priority (A, B, C, etc.)">
          <div class="buttons">
            <button class="confirm">Set Priority</button>
            <button class="cancel">Cancel</button>
          </div>
        `;
        showDialog(htmlContent, (newPriority) => {
          if (newPriority) {
            const originalIndices = getOriginalIndices();
            originalIndices.forEach(index => {
              allTasks[index].Task = allTasks[index].Task.replace(/^\(.\)/, `(${newPriority})`);
            });
            applyFilters();
          }
        });
      }
 */   
      function deleteTask(index) {
        const task = allTasks[index];
        const htmlContent = `
          <h2>Delete Task(s)</h2>
          <input type=hidden value="delete">
          <p>Are you sure?</p>
          <div class="buttons">
            <button class="confirm" data-confirmed="true">Delete</button>
            <button class="cancel" data-confirmed="false">Cancel</button>
          </div>
        `;
        showDialog(htmlContent, (confirmed) => {
          if (confirmed) {
            const originalIndices = getOriginalIndices().sort((a, b) => b - a);  // Sort in reverse order
            originalIndices.forEach(idx => {
              allTasks.splice(idx, 1);
            });
            applyFilters();
          }
        });
      }

      function changePriority(tasks, increase) {
      const priorities = ['A', 'B', 'C', 'D'];

      tasks.forEach(task => {
        if (!task.Task.startsWith('(')) return;
        
        const currentPriority = task.Task[1];
        const currentIndex = priorities.indexOf(currentPriority);
        
        if (currentIndex === -1) return;
        
        let newIndex = increase ? 
          Math.max(0, currentIndex - 1) : 
          Math.min(priorities.length - 1, currentIndex + 1);
          
        task.Task = `(${priorities[newIndex]})${task.Task.slice(3)}`;
      });
      }

      function setPriorityForSelectedTasks() {
        const htmlContent = `
          <h2>Set Priority</h2>
          <input type="text" placeholder="Enter the new priority (A, B, C, etc.)">
          <div class="buttons">
            <button class="confirm">Set Priority</button>
            <button class="cancel">Cancel</button>
          </div>
        `;
        showDialog(htmlContent, (newPriority) => {
          if (newPriority) {
            const originalIndices = getOriginalIndices();
            originalIndices.forEach(index => {
              allTasks[index].Task = allTasks[index].Task.replace(/^\(.\)/, `(${newPriority})`);
            });
            applyFilters();
          }
        });
      }

      // Function to postpone selected tasks
      function postponeSelectedTasks() {
        const htmlContent = `
        <h2>Postpone</h2>
        <input type="number" placeholder="Enter the number of days to postpone">
        <div class="buttons">
            <button class="confirm">Postpone</button>
            <button class="cancel">Cancel</button>
          </div>
        `;
        showDialog(htmlContent, (days) => {
          if (days) {
			      const originalIndices = getOriginalIndices();
            originalIndices.forEach(index => {
              const task = allTasks[index];
              const dueDateMatch = task.Task.match(/due:(\d{4}-\d{2}-\d{2})/);
              if (dueDateMatch) {
                const dueDate = new Date(dueDateMatch[1]);
                dueDate.setDate(dueDate.getDate() + parseInt(days));
                const newDueDate = dueDate.toISOString().split('T')[0];
                allTasks[index].Task = task.Task.replace(/due:\d{4}-\d{2}-\d{2}/, `due:${newDueDate}`);
              }
            });
            applyFilters();
          }
        });
      }

      function showDialog(htmlContent, callback) {
        const dialogContainer = document.getElementById('dialogContainer');
        dialogContainer.innerHTML = `
          <div class="sidebar-dialog">
            ${htmlContent}
          </div>
        `;
          
        const dialog = dialogContainer.querySelector('.sidebar-dialog');
        setTimeout(() => dialog.classList.add('active'), 10); // Trigger animation

        const input = dialog.querySelector('input:not([type="hidden"]), textarea');
        const confirmButton = dialog.querySelector('.confirm');

        // Focus on input if it exists and is visible, otherwise focus on confirm button
        if (input && input.type !== 'hidden' && window.getComputedStyle(input).display !== 'none') {
          input.focus();
          input.addEventListener('keydown', (e) => {
            e.stopPropagation();
          });
        } else if (confirmButton) {
          setTimeout(() => confirmButton.focus(), 50);
        }

        // Add click handler for the dialog container
        const handleOutsideClick = (e) => {
          if (!dialog.contains(e.target)) {
            closeDialog();
          }
        };

        const closeDialog = () => {
          dialog.classList.remove('active');
          setTimeout(() => {
            callback(null);
            dialogContainer.innerHTML = '';
            document.removeEventListener('click', handleOutsideClick);
          }, 300);
        };

        dialog.querySelector('.confirm').onclick = () => {
          const input = dialog.querySelector('input, textarea');
          dialog.classList.remove('active');
          setTimeout(() => {
            callback(input.value);
            dialogContainer.innerHTML = '';
            document.removeEventListener('click', handleOutsideClick);
          }, 300);
        };

        dialog.querySelector('.cancel').onclick = () => {
          closeDialog();
        };

        setTimeout(() => {
          document.addEventListener('click', handleOutsideClick);
        }, 100);
      }

      function getOriginalIndices() {
        const taskList = document.getElementById('taskList');
        const tasks = taskList.getElementsByClassName('task');
        return Array.from(selectedTasks).map(index => parseInt(tasks[index].dataset.originalIndex));
      }

      function handleTaskClick(event, index) {
        const taskList = document.getElementById('taskList');
        const tasks = taskList.getElementsByClassName('task');
        const originalIndex = parseInt(tasks[index].dataset.originalIndex);

        if (event.detail === 2) {
          editTask(originalIndex);
        } else {
          if (event.ctrlKey) {
            tasks[index].classList.toggle('selected');
            if (selectedTasks.has(index)) {
              selectedTasks.delete(index);
            } else {
              selectedTasks.add(index);
            }
          } else if (event.shiftKey && lastSelectedIndex !== -1) {
            const start = Math.min(lastSelectedIndex, index);
            const end = Math.max(lastSelectedIndex, index);
            for (let i = start; i <= end; i++) {
              tasks[i].classList.add('selected');
              selectedTasks.add(i);
            }
          } else {
            Array.from(tasks).forEach(task => task.classList.remove('selected'));
            tasks[index].classList.add('selected');
            selectedTasks.clear();
            selectedTasks.add(index);
          }
          lastSelectedIndex = index;
        }
      }

      function handleKeyDown(event) {
        // Ignore hotkeys if search box is focused or dialog box is open
        if (document.activeElement === document.getElementById('searchBox') || document.getElementById('dialogContainer').innerHTML !== '') {
          return;
        }
        const taskList = document.getElementById('taskList');
        const tasks = taskList.getElementsByClassName('task');
        if (lastSelectedIndex === -1) return;

        if (event.key === 'ArrowUp') {
          if (event.ctrlKey && lastSelectedIndex > 0) {
            swapTasks(lastSelectedIndex, lastSelectedIndex - 1);
          } else if (event.altKey) {
            const selectedTaskObjects = getOriginalIndices().map(i => allTasks[i]);
            changePriority(selectedTaskObjects, true);
            applyFilters();
            const taskList = document.getElementById('taskList');
            const tasks = taskList.getElementsByClassName('task');
            selectedTasks.forEach(index => {
              tasks[index].classList.add('selected');
            });
          } else if (lastSelectedIndex > 0) {
            if (event.shiftKey) {
              // If shift is pressed, toggle selection of the previous task
              const newIndex = lastSelectedIndex - 1;
              if (selectedTasks.has(newIndex)) {
                tasks[lastSelectedIndex].classList.remove('selected');
                selectedTasks.delete(lastSelectedIndex);
              } else {
                tasks[newIndex].classList.add('selected');
                selectedTasks.add(newIndex);
              }
              lastSelectedIndex = newIndex;
            } else {
              // If no shift, clear all selections and select only the new task
              Array.from(tasks).forEach(task => task.classList.remove('selected'));
              lastSelectedIndex--;
              tasks[lastSelectedIndex].classList.add('selected');
              selectedTasks.clear();
              selectedTasks.add(lastSelectedIndex);
            }
          }
        } else if (event.key === 'ArrowDown') {
          if (event.ctrlKey && lastSelectedIndex < tasks.length - 1) {
            swapTasks(lastSelectedIndex, lastSelectedIndex + 1);
          } else if (event.altKey) {
            const selectedTaskObjects = getOriginalIndices().map(i => allTasks[i]);
            changePriority(selectedTaskObjects, false);
            applyFilters();
            const taskList = document.getElementById('taskList');
            const tasks = taskList.getElementsByClassName('task');
            selectedTasks.forEach(index => {
              tasks[index].classList.add('selected');
            });
          } else if (lastSelectedIndex < tasks.length - 1) {
            if (event.shiftKey) {
              // If shift is pressed, toggle selection of the next task
              const newIndex = lastSelectedIndex + 1;
              if (selectedTasks.has(newIndex)) {
                tasks[lastSelectedIndex].classList.remove('selected');
                selectedTasks.delete(lastSelectedIndex);
              } else {
                tasks[newIndex].classList.add('selected');
                selectedTasks.add(newIndex);
              }
              lastSelectedIndex = newIndex;
            } else {
              // If no shift, clear all selections and select only the new task
              Array.from(tasks).forEach(task => task.classList.remove('selected'));
              lastSelectedIndex++;
              tasks[lastSelectedIndex].classList.add('selected');
              selectedTasks.clear();
              selectedTasks.add(lastSelectedIndex);
            }
          }
        } else if (event.key === 'c') {
          copySelectedTasks();
        } else if (event.ctrlKey && event.altKey && event.key >= '1' && event.key <= '9') {
          saveFilterSet(event.key);
        } else if (event.key >= '1' && event.key <= '9') {
          loadFilterSet(event.key);
        } else if (event.key === 'x') {
          const selectedTaskObjects = getOriginalIndices().map(i => allTasks[i]);
          toggleCompletion(selectedTaskObjects);
          applyFilters();
          const taskList = document.getElementById('taskList');
          const tasks = taskList.getElementsByClassName('task');
          selectedTasks.forEach(index => {
            tasks[index].classList.add('selected');
          });
        } else if (event.key === 'd') {
          event.preventDefault();
          deleteTask(filteredTasks[lastSelectedIndex].originalIndex);
        } else if (event.key === 'n') {
          event.preventDefault();
          addNewTask();
        } else if (event.key === 's') {
          event.preventDefault();
          setDateForSelectedTasks();
        } else if (event.key === 'i') {
          event.preventDefault();
          setPriorityForSelectedTasks();
        } else if (event.key === 'p') {
          event.preventDefault();
          postponeSelectedTasks();
        }
      }

      // automatically save waiting for 'saveTimeout' milliseconds
      let timeoutId;
      // Function to listen for keyboard input
      function listenForKeyboardInput() {
        document.addEventListener('keydown', resetTimer);
      }
      // Function to reset the timer
      function resetTimer() {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(saveTasks, saveTimeout);
      }
      // Function to save all tasks to a text file
      function saveTasks() {
        const allTasksText = allTasks.map(task => task.Task).join('\n');
        google.script.run.saveTasksToFile(allTasksText);
      }
      // Start listening for keyboard input
      listenForKeyboardInput();

      document.addEventListener('DOMContentLoaded', loadTasks);
      document.addEventListener('keydown', handleKeyDown);
	  
	    // Add this line to focus the page on load
	    window.onload = () => document.body.focus();
	  
    </script>
  </body>
</html>
