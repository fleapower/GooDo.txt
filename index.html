<!DOCTYPE html>
<html>
  <head>
    <base target="_top">
    <?!= include('styles'); ?>
  </head>
  <body tabindex="0">
    <h1>GooDo.txt
    <button class="button" onclick="loadNewFile()">Load ToDo.txt file</button>
    </h1>
    <div id="dialogContainer"></div>
    <div id="headerContainer" class="header-bar">
      <div class="filter-bar">
        <button class="button" id="completeButton" onclick="cycleCompleteState()">All States</button>
        <button class="button" id="dueButton" onclick="cycleDueState()">All Dates</button>
        <button class="button" id="priorityButton" onclick="cyclePriorityState()">All Pri</button>
        <button class="button" id="sortButton" onclick="cycleSortState()">Sort: File</button>
        <button class="button" onclick="clearFilters()">Clear Filters</button>
        <input type="text" id="searchBox" placeholder="Find..." oninput="applyFilters()">

        <script>
          const searchBox = document.getElementById('searchBox');
          
          searchBox.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
              searchBox.value = '';
              applyFilters(); // Optional: Call applyFilters to clear filters when the search box is cleared
            }
          });
        </script>
      </div>
      <div id="contextButtons" class="context-bar">
      </div>
    </div>
    <div id="taskList"></div>
    <script>
      
      let allTasks = [];
      let lastModifiedTime = null;
      let lastSavedTime = null;
      let lastSelectedIndex = -1;
      let selectedTasks = new Set();
      let activeContexts = new Set();
      let filteredTasks = [];
      let dueState = "All Dates";
      let priorityState = "All Pri";
      let completeState = "All States";  // Can be "All States", "Complete", or "Pending"
      let currentSortState = 'file'; // Can be 'file', 'date', or 'priority'
      let validPriorities = [];
      let cutTasks = [];

      const saveTimeout = 3000; // You can increase this if you are getting an error that too many scripts are running on your account.  This is in milliseconds.

      // functions which need to be loaded up front are in index.html, others are in the following files //
      <?!= include('displayFunctions.html') ?>
      <?!= include('fileFunctions.html') ?>
      <?!= include('taskFunctions.html') ?>

      function loadTasks() {
        google.script.run
          .withSuccessHandler(function(result) {
            lastModifiedTime = result.lastModified;
            lastSavedTime = result.lastModified;
            displayTasks(result.tasks);
          })
          .getTasksAndModifiedTime();
      }

      function displayTasks(tasks) {
        allTasks = tasks;
        generateContextButtons();
        applyFilters();
      }
  
      function updateTaskCount() {
      const taskList = document.getElementById('taskList');
      const counter = document.createElement('div');
      counter.style.cssText = 'position: fixed; bottom: 10px; right: 10px; padding: 5px; border: 1px solid #ccc; background: white;';
      counter.textContent = `${filteredTasks.length}/${allTasks.length}`;
      taskList.appendChild(counter);
      }

      function generateContextButtons() {
        const contextButtons = document.getElementById('contextButtons');
        const contexts = new Set();
        allTasks.forEach(task => {
          const match = task.Task.match(/ @\w+/g);
          if (match) {
            match.forEach(context => contexts.add(context.trim()));
          }
        });
        contextButtons.innerHTML = '';

        // Add "No Lists" button
        const noContextsButton = document.createElement('button');
        noContextsButton.className = 'context-button';
        noContextsButton.textContent = 'No Lists';
        noContextsButton.dataset.context = 'No Lists';
        noContextsButton.onclick = () => toggleContextFilter('No Lists');
        contextButtons.appendChild(noContextsButton);

        Array.from(contexts).sort().forEach(context => {
          const button = document.createElement('button');
          button.className = 'context-button';
          button.textContent = context;
          button.dataset.context = context;
          button.onclick = () => toggleContextFilter(context);
          contextButtons.appendChild(button);
        });
      }

      // Helper function to extract priority from task text
      function extractPriority(taskText) {
        const match = taskText.match(/\(([A-I])\)/);
        return match ? match[1] : null;
      }

      function displaySortedTasks() {
        switch (currentSortState) {
          case 'date':
            sortTasksByDueDate();
            break;
          case 'priority':
            sortTasksByPriority();
            break;
          default:
            break;
        }
        const taskList = document.getElementById('taskList');
        taskList.innerHTML = '';
        
        filteredTasks.forEach(({ task, originalIndex }, filteredIndex) => {
          const div = document.createElement('div');
          div.className = 'task';
          div.dataset.taskId = task.TaskID;
          div.dataset.originalIndex = originalIndex;
          div.dataset.filteredIndex = filteredIndex;
          div.onclick = (event) => handleTaskClick(event, filteredIndex);

          // Task display formatting
          let taskText = task.Task
            .replace(/\(A\)/g, '<span class="priority-a">(A)</span>')
            .replace(/\(B\)/g, '<span class="priority-b">(B)</span>')
            .replace(/\(C\)/g, '<span class="priority-c">(C)</span>')
            .replace(/\(D\)/g, '<span class="priority-d">(D)</span>')
            .replace(/\b([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})\b/g, function(match) {
              return `<a href="mailto:${match}" target="_blank">${match}</a>`;
            })
            .replace(/\b(https?:\/\/\S+)/gi, '<a href="$1" target="_blank">$1</a>')
            .replace(/\b(due:\S+)\b/g, '<span class="context">$1</span>')
            .replace(/([+]\S+)/g, '<span class="context">$1</span>')
            .replace(/\b(r:\S+)\b/g, '<span class="context">$1</span>')
            .replace(/\b(last:\S+)\b/g, '<span class="context">$1</span>')
            .replace(/\b(\s@\S+)\b/g, '<span class="context">$1</span>');

          const dueDate = taskText.substring(taskText.indexOf('due:') + 4, taskText.indexOf('due:') + 14);
          const today = getTodayDate();
          if (dueDate < today) {
            taskText = `<span class="overdue-task">${taskText}</span>`;
          }

          if (task.Task.startsWith('x ')) {
            taskText = `<span class="complete-task">${taskText}</span>`;
          }

          div.innerHTML = taskText;
          taskList.appendChild(div);
        });

        updateTaskCount();

        if (lastSelectedIndex === -1 && taskList.children.length > 0) {
          const firstTask = taskList.children[0];
          firstTask.classList.add('selected');
          selectedTasks.clear();
          selectedTasks.add(0);
          lastSelectedIndex = 0;
        }

      }

      function applyFilters() {
        /*
        if (currentSortState !== 'file') {
          currentSortState = 'file';
        }
        */

        updateValidPriorities(); // update in case they have been changed
        
        const searchBox = document.getElementById('searchBox');
        const searchQuery = searchBox.value;
        
        // Split search terms while preserving quoted strings and AND groups
        const searchTerms = searchQuery.match(/(?:[^\s"]+|"[^"]*")+/g) || [''];
        
        filteredTasks = allTasks
          .map((task, originalIndex) => ({ task, originalIndex }))
          .filter(({ task }) => {
            const taskText = task.Task;
            const dueDate = taskText.match(/due:(\d{4}-\d{2}-\d{2})/)?.[1] || '';
            const today = getTodayDate();
            const tomorrow = getTomorrowDate();
            const isComplete = taskText.startsWith('x ');
            const taskPriority = extractPriority(taskText);
            
            const matchesDue = dueState === "All Dates" || 
              (dueState === "Due Today" && dueDate <= today) ||
              (dueState === "Due Tomorrow" && dueDate === tomorrow);
            
            const matchesComplete = completeState === "All States" ||
              (completeState === "Complete" && isComplete) ||
              (completeState === "Pending" && !isComplete);
            
            const matchesPriority = priorityState === "All Pri" || 
              (taskPriority && `(${taskPriority})` === priorityState);
            
            const matchesContexts = Array.from(activeContexts).length === 0 || Array.from(activeContexts).some(context => {
              if (context === 'No Lists') return !taskText.match(/ @\w+/);
              return taskText.includes(context);
            });

            // Use the advanced search filter functionality
            const matchesSearch = applySearchFilter(taskText, searchTerms);
            
            return matchesDue && matchesComplete && matchesSearch && matchesPriority && matchesContexts;
          });

        // Display the filtered (and possibly sorted) tasks
        displaySortedTasks();
      }

      function swapTasks(filteredIndex1, filteredIndex2) {
        if (currentSortState !== 'file') {
          // Don't allow swapping when sorted
          return;
        }
        // Get the original indices from the filtered tasks
        const originalIndex1 = filteredTasks[filteredIndex1].originalIndex;
        const originalIndex2 = filteredTasks[filteredIndex2].originalIndex;

        // Swap in the allTasks array
        const tempTask = allTasks[originalIndex1];
        allTasks[originalIndex1] = allTasks[originalIndex2];
        allTasks[originalIndex2] = tempTask;

        // Update TaskIDs
        allTasks[originalIndex1].TaskID = originalIndex1;
        allTasks[originalIndex2].TaskID = originalIndex2;

        // Instead of rebuilding everything, directly swap the DOM elements
        const taskList = document.getElementById('taskList');
        const tasks = taskList.getElementsByClassName('task');
        const task1 = tasks[filteredIndex1];
        const task2 = tasks[filteredIndex2];
        
        // Cache the task height before any DOM changes
        const taskHeight = task1.offsetHeight;
        
        // Create a temporary marker for task2's position
        const temp = document.createElement('div');
        task2.parentNode.insertBefore(temp, task2);
        
        // Perform the DOM swap
        task1.parentNode.insertBefore(task2, task1);
        temp.parentNode.insertBefore(task1, temp);
        temp.parentNode.removeChild(temp);
        
        // Update selection - keep the original selected task highlighted as it moves
        Array.from(tasks).forEach(task => task.classList.remove('selected'));
        task1.classList.add('selected');
        selectedTasks.clear();
        selectedTasks.add(filteredIndex2);
        lastSelectedIndex = filteredIndex2;

        // Update filteredTasks array to match DOM
        filteredTasks[filteredIndex1] = { task: allTasks[originalIndex1], originalIndex: originalIndex1 };
        filteredTasks[filteredIndex2] = { task: allTasks[originalIndex2], originalIndex: originalIndex2 };
        
        // Calculate scroll position based on cached task height
        const rect = task1.getBoundingClientRect();
        const tasksFromTop = Math.floor(rect.top / taskHeight);
        const tasksFromBottom = Math.floor((window.innerHeight - rect.bottom) / taskHeight);
        
        // Only scroll if necessary
        if (tasksFromTop < 5) {
          window.scrollBy({
            top: -((5 - tasksFromTop) * taskHeight),
            behavior: 'instant'
          });
        } else if (tasksFromBottom < 5) {
          window.scrollBy({
            top: ((5 - tasksFromBottom) * taskHeight),
            behavior: 'instant'
          });
        }
        
        // Store the task text that should remain selected after refresh
        const selectedTaskText = task1.textContent;
        
        // Debounce the full refresh to run after user stops moving tasks
        clearTimeout(window.refreshTimeout);
        window.refreshTimeout = setTimeout(() => {
          applyFilters();
          // After refresh, find and reselect the task
          const newTaskList = document.getElementById('taskList');
          const newTasks = newTaskList.getElementsByClassName('task');
          for (let i = 0; i < newTasks.length; i++) {
            if (newTasks[i].textContent === selectedTaskText) {
              newTasks[i].classList.add('selected');
              selectedTasks.clear();
              selectedTasks.add(i);
              lastSelectedIndex = i;
              break;
            }
          }
        }, 500);
      }

      // Function to get today's date in user's local time zone in YYYY-MM-DD format
      function getTodayDate() {
        const today = new Date();
        return today.toLocaleDateString('en-CA'); // 'en-CA' locale for YYYY-MM-DD format
      }

      // Function to get tomorrow's date in user's local time zone in YYYY-MM-DD format
      function getTomorrowDate() {
        const tomorrow = new Date();
        tomorrow.setDate(tomorrow.getDate() + 1);
        return tomorrow.toLocaleDateString('en-CA');
      }

      class Calendar {
        constructor(container, options = {}) {
          this.container = container;
          this.onChange = options.onChange || (() => {});
          this.selectedDate = null;
          this.currentDate = new Date();
          this.today = new Date().toISOString().split('T')[0]; // Store today's date in YYYY-MM-DD format
          this.render();
        }

        render() {
          const monthNames = ["January", "February", "March", "April", "May", "June",
            "July", "August", "September", "October", "November", "December"];
          
          const calendar = document.createElement('div');
          calendar.className = 'calendar';
          
          // Header with month/year and navigation
          const header = document.createElement('div');
          header.className = 'calendar-header';
          header.innerHTML = `
            <button class="prev-month">&lt;</button>
            <span>${monthNames[this.currentDate.getMonth()]} ${this.currentDate.getFullYear()}</span>
            <button class="next-month">&gt;</button>
          `;
          
          calendar.appendChild(header);
          
          // Calendar grid
          const grid = document.createElement('div');
          grid.className = 'calendar-grid';

          // Days of week header
          const daysOfWeek = ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"];
          daysOfWeek.forEach(day => {
            const dayDiv = document.createElement('div');
            dayDiv.className = 'calendar-day';
            dayDiv.textContent = day;
            grid.appendChild(dayDiv);
          });
          
          const firstDay = new Date(this.currentDate.getFullYear(), this.currentDate.getMonth(), 1);
          const lastDay = new Date(this.currentDate.getFullYear(), this.currentDate.getMonth() + 1, 0);
          const startingDay = firstDay.getDay();
          
          // Add empty cells for days before the first of the month
          for (let i = 0; i < startingDay; i++) {
            const emptyDay = document.createElement('div');
            emptyDay.className = 'calendar-day empty';
            grid.appendChild(emptyDay);
          }
          
          // Add days of the month
          for (let day = 1; day <= lastDay.getDate(); day++) {
            const dayDiv = document.createElement('div');
            dayDiv.className = 'calendar-day';
            dayDiv.textContent = day;
            
            const date = new Date(this.currentDate.getFullYear(), this.currentDate.getMonth(), day);
            const dateString = date.toISOString().split('T')[0];
            dayDiv.dataset.date = dateString;
            
            // Add today highlight
            if (dateString === this.today) {
              dayDiv.classList.add('today');
              dayDiv.style.backgroundColor = '#90EE90'; // Light green background
              dayDiv.style.fontWeight = 'bold';
            }
            
            if (this.selectedDate === dateString) {
              dayDiv.classList.add('selected');
            }
            
            dayDiv.addEventListener('click', () => {
              const oldSelected = grid.querySelector('.selected');
              if (oldSelected) oldSelected.classList.remove('selected');
              
              dayDiv.classList.add('selected');
              this.selectedDate = dayDiv.dataset.date;
              this.onChange(this.selectedDate);
            });
            
            grid.appendChild(dayDiv);
          }
          
          calendar.appendChild(grid);
          
          // Event listeners for navigation
          header.querySelector('.prev-month').addEventListener('click', () => {
            this.currentDate.setMonth(this.currentDate.getMonth() - 1);
            this.render();
          });
          
          header.querySelector('.next-month').addEventListener('click', () => {
            this.currentDate.setMonth(this.currentDate.getMonth() + 1);
            this.render();
          });
          
          // Replace existing calendar if any
          this.container.innerHTML = '';
          this.container.appendChild(calendar);
        }
      }

      function initCalendar(container) {
        const calendar = document.createElement('div');
        calendar.className = 'calendar';
        container.appendChild(calendar);
        
        const date = new Date();
        const currentMonth = date.getMonth();
        const currentYear = date.getFullYear();
        
        const monthNames = ["January", "February", "March", "April", "May", "June",
          "July", "August", "September", "October", "November", "December"];
          
        calendar.innerHTML = `
          <div class="calendar-header">
            <button class="prev-month">&lt;</button>
            <span>${monthNames[currentMonth]} ${currentYear}</span>
            <button class="next-month">&gt;</button>
          </div>
          <div class="calendar-grid">
            ${generateCalendarDays(currentYear, currentMonth)}
          </div>
        `;
        
        // Add event listeners for navigation and date selection
        const prevButton = calendar.querySelector('.prev-month');
        const nextButton = calendar.querySelector('.next-month');
        
        prevButton.addEventListener('click', () => {
          date.setMonth(date.getMonth() - 1);
          updateCalendar(calendar, date);
        });
        
        nextButton.addEventListener('click', () => {
          date.setMonth(date.getMonth() + 1);
          updateCalendar(calendar, date);
        });
        
        return calendar;
      }

      function generateCalendarDays(year, month) {
        const firstDay = new Date(year, month, 1);
        const lastDay = new Date(year, month + 1, 0);
        const startDay = firstDay.getDay();
        const daysInMonth = lastDay.getDate();
        
        let html = '<div class="weekdays">Su Mo Tu We Th Fr Sa</div>';
        let day = 1;
        
        for (let i = 0; i < 6; i++) {
          html += '<div class="week">';
          for (let j = 0; j < 7; j++) {
            if ((i === 0 && j < startDay) || day > daysInMonth) {
              html += '<span class="empty"></span>';
            } else {
              html += `<span class="day" data-date="${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}">${day}</span>`;
              day++;
            }
          }
          html += '</div>';
          if (day > daysInMonth) break;
        }
        
        return html;
      }

      function updateCalendar(calendar, date) {
        const monthNames = ["January", "February", "March", "April", "May", "June",
          "July", "August", "September", "October", "November", "December"];
        
        calendar.querySelector('.calendar-header span').textContent = 
          `${monthNames[date.getMonth()]} ${date.getFullYear()}`;
        
        calendar.querySelector('.calendar-grid').innerHTML = 
          generateCalendarDays(date.getFullYear(), date.getMonth());
      }


      function showDialog(htmlContent, callback) {
        const dialogContainer = document.getElementById('dialogContainer');
        dialogContainer.innerHTML = `
          <div class="sidebar-dialog">
            ${htmlContent}
          </div>
        `;
          
        const dialog = dialogContainer.querySelector('.sidebar-dialog');
        setTimeout(() => dialog.classList.add('active'), 10);

        const closeDialog = () => {
          dialog.classList.remove('active');
          setTimeout(() => {
            callback(null);
            dialogContainer.innerHTML = '';
            document.removeEventListener('click', handleOutsideClick);
            document.removeEventListener('keydown', handleEscapeKey);
          }, 300);
        };

        const handleOutsideClick = (e) => {
          // Prevent closing if clicking calendar navigation buttons
          if (e.target.classList.contains('prev-month') || 
              e.target.classList.contains('next-month')) {
            e.stopPropagation();
            return;
          }
          
          if (!dialog.contains(e.target)) {
            closeDialog();
          }
        };

        const handleEscapeKey = (e) => {
          if (e.key === 'Escape') {
            e.preventDefault();
            closeDialog();
          }
        };

        // Focus priority: visible input/textarea first, then confirm button
        const input = dialog.querySelector('input:not([type="hidden"]), textarea');
        const confirmButton = dialog.querySelector('.confirm');

        if (input && window.getComputedStyle(input).display !== 'none') {
          // Delay focus slightly to ensure the dialog is fully rendered
          setTimeout(() => {
            input.focus();
            if (input.tagName.toLowerCase() === 'input') {
              input.select(); // Select all text in input fields
            }
          }, 50);

          input.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
              e.preventDefault();
              closeDialog();
              return;
            }
            if (e.key === 'Enter' && !e.shiftKey) {
              e.preventDefault();
              dialog.classList.remove('active');
              setTimeout(() => {
                callback(input.value);
                dialogContainer.innerHTML = '';
                document.removeEventListener('click', handleOutsideClick);
                document.removeEventListener('keydown', handleEscapeKey);
              }, 300);
            }
          });
        } else if (confirmButton) {
          // If no input or hidden input, focus the confirm button
          setTimeout(() => confirmButton.focus(), 50);
        }

        if (confirmButton) {
          confirmButton.onclick = () => {
            dialog.classList.remove('active');
            setTimeout(() => {
              const inputElement = dialog.querySelector('input, textarea');
              const value = inputElement && inputElement.type !== 'hidden' ? inputElement.value : true;
              callback(value);
              dialogContainer.innerHTML = '';
              document.removeEventListener('click', handleOutsideClick);
              document.removeEventListener('keydown', handleEscapeKey);
            }, 300);
          };
        }

        const cancelButton = dialog.querySelector('.cancel');
        if (cancelButton) {
          cancelButton.onclick = closeDialog;
        }

        // Initialize calendar after dialog content is rendered
        const calendarContainer = dialog.querySelector('#calendar');
        if (calendarContainer) {
          // Wait for DOM to be fully rendered
          setTimeout(() => {
            const calendar = new Calendar(calendarContainer, {
              onChange: (date) => {
                const textarea = dialog.querySelector('textarea');
                if (textarea) {
                  const cursorPos = textarea.selectionStart;
                  const textBefore = textarea.value.substring(0, cursorPos);
                  const textAfter = textarea.value.substring(textarea.selectionEnd);
                  
                  // Check if there's already a due date
                  const dueDate = textarea.value.match(/due:\d{4}-\d{2}-\d{2}/);
                  if (dueDate) {
                    textarea.value = textarea.value.replace(/due:\d{4}-\d{2}-\d{2}/, `due:${date}`);
                  } else {
                    textarea.value = textBefore + ` due:${date} ` + textAfter;
                  }
                  
                  textarea.focus();
                }
              }
            });
          }, 0);
        }

        // Add event listeners after a short delay
        setTimeout(() => {
          document.addEventListener('click', handleOutsideClick);
          document.addEventListener('keydown', handleEscapeKey);
        }, 100);
      }

      function getOriginalIndices() {
        const taskList = document.getElementById('taskList');
        const tasks = taskList.getElementsByClassName('task');
        return Array.from(selectedTasks).map(index => parseInt(tasks[index].dataset.originalIndex));
      }

      function checkFileModified() {
        return new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(function(currentModifiedTime) {
              if (currentModifiedTime !== lastModifiedTime) {
                const htmlContent = `
                  <h2>Warning: File Modified</h2>
                  <p>The task file has been modified externally since it was last loaded.</p>
                  <p>Do you want to:</p>
                  <div class="buttons">
                    <button class="confirm">Save Anyway</button>
                    <button class="cancel" autofocus>Cancel Save (CTRL-R is recommended to refresh the task list)</button>
                  </div>
                `;
                showDialog(htmlContent, (confirmed) => {
                  resolve(confirmed === null ? false : true);
                });
              } else {
                resolve(true);
              }
            })
            .withFailureHandler(function(error) {
              reject(error);
            })
            .getLastModifiedTime();
        });
      }

      // Function to save all tasks to a text file
      async function saveTasks() {
        try {
          const canSave = await checkFileModified();
          if (canSave) {
            const allTasksText = allTasks.map(task => task.Task).join('\n');
            google.script.run
              .withSuccessHandler(function(newModifiedTime) {
                lastModifiedTime = newModifiedTime;
                lastSavedTime = newModifiedTime;
              })
              .saveTasksToFile(allTasksText);
          } else {
            // Optionally reload the file here if user cancels
            loadTasks();
          }
        } catch (error) {
          const htmlContent = `
            <h2>Error</h2>
            <p>Failed to check file status: ${error}</p>
            <div class="buttons">
              <button class="confirm">OK</button>
              <button class="cancel" style="display: none;">Cancel</button>
            </div>
          `;
          showDialog(htmlContent, () => {});
        }
      }
      function loadNewFile() {
        const dialogContent = `
          <h2>Loading Files...</h2>
          <p>Searching for todo files in your Google Drive...</p>
        `;
        
        showDialog(dialogContent, null);
        
        google.script.run
          .withSuccessHandler((files) => {
            const fileList = files && files.length > 0 ? files.map(file => `
              <div class="file-item" data-id="${file.id}">
                <span class="file-name">${file.name}</span>
                <span class="file-info">
                  Modified: ${new Date(file.date).toLocaleString()}
                  (${(file.size / 1024).toFixed(1)} KB)
                </span>
              </div>
            `).join('') : '';
            
            const htmlContent = `
              <h2>Todo Files</h2>
              ${files && files.length > 0 ? `
                <p>Select an existing todo file or create a new one:</p>
                <div class="file-browser">
                  ${fileList}
                </div>
              ` : `
                <p>No existing todo files found.</p>
              `}
              <div class="new-file-section">
                <button class="button new-file-button">Create New Todo File</button>
              </div>
              <div class="buttons">
                ${files && files.length > 0 ? `
                  <button class="confirm" disabled>Select File</button>
                ` : ''}
                <button class="cancel">Cancel</button>
              </div>
            `;

            const handleFileCreation = () => {
              const createFileContent = `
                <h2>Create New Todo File</h2>
                <input type="text" 
                      placeholder="Enter file name (e.g., todo.txt)" 
                      value="todo.txt"
                      pattern=".+\\.txt$">
                <p class="input-hint">File name must end with .txt</p>
                <div class="buttons">
                  <button class="confirm">Create</button>
                  <button class="cancel">Cancel</button>
                </div>
              `;

              showDialog(createFileContent, (fileName) => {
                if (fileName) {
                  if (!fileName.toLowerCase().endsWith('.txt')) {
                    fileName += '.txt';
                  }

                  const loadingContent = `
                    <h2>Creating File...</h2>
                    <p>Please wait while we set up your new todo file.</p>
                  `;
                  showDialog(loadingContent, null);

                  google.script.run
                    .withSuccessHandler((fileId) => {
                      if (fileId) {
                        // First set up the file ID
                        google.script.run
                          .withSuccessHandler((success) => {
                            if (success) {
                              const successContent = `
                                <h2>File Created</h2>
                                <p>Your new todo file has been created and set up.</p>
                                <p>Please press CTRL-R to refresh the to-do list.</p>
                                <div class="buttons">
                                  <button class="confirm" autofocus>OK</button>
                                </div>
                              `;
                              showDialog(successContent, () => {
                                setTimeout(() => {
                                  window.top.location.reload();
                                }, 100);
                              });
                            } else {
                              const errorContent = `
                                <h2>Error</h2>
                                <p>Failed to set up the new file.</p>
                                <div class="buttons">
                                  <button class="confirm" autofocus>OK</button>
                                </div>
                              `;
                              showDialog(errorContent, () => {});
                            }
                          })
                          .withFailureHandler((error) => {
                            const errorContent = `
                              <h2>Error</h2>
                              <p>Failed to set up file: ${error}</p>
                              <div class="buttons">
                                <button class="confirm" autofocus>OK</button>
                              </div>
                            `;
                            showDialog(errorContent, () => {});
                          })
                          .setupFileId(fileId);
                      } else {
                        const errorContent = `
                          <h2>Error</h2>
                          <p>Failed to create the new file.</p>
                          <div class="buttons">
                            <button class="confirm" autofocus>OK</button>
                          </div>
                        `;
                        showDialog(errorContent, () => {});
                      }
                    })
                    .withFailureHandler((error) => {
                      const errorContent = `
                        <h2>Error</h2>
                        <p>Failed to create file: ${error}</p>
                        <div class="buttons">
                          <button class="confirm" autofocus>OK</button>
                        </div>
                      `;
                      showDialog(errorContent, () => {});
                    })
                    .createNewTodoFile(fileName);
                }
              });
            };
                  
            // Single function to handle file selection
            const handleFileSelection = (fileId) => {
              const loadingContent = `
                <h2>Loading File...</h2>
                <p>Please wait while we set up your todo file.</p>
              `;
              showDialog(loadingContent, null);
              
              google.script.run
                .withSuccessHandler((success) => {
                  if (success) {
                    const successContent = `
                      <h2>File Loaded</h2>
                      <p>Please press CTRL-R to refresh the to-do list.</p>
                      <div class="buttons">
                        <button class="confirm" autofocus>OK</button>
                      </div>
                    `;
                    showDialog(successContent, () => {
                      setTimeout(() => {
                        window.top.location.reload();
                      }, 100);
                    });
                  } else {
                    const errorContent = `
                      <h2>Error</h2>
                      <p>Failed to load the selected file.</p>
                      <div class="buttons">
                        <button class="confirm" autofocus>OK</button>
                      </div>
                    `;
                    showDialog(errorContent, () => {});
                  }
                })
                .withFailureHandler((error) => {
                  const errorContent = `
                    <h2>Error</h2>
                    <p>Failed to set up file: ${error}</p>
                    <div class="buttons">
                      <button class="confirm" autofocus>OK</button>
                    </div>
                  `;
                  showDialog(errorContent, () => {});
                })
                .setupFileId(fileId);
            };
            
            showDialog(htmlContent, () => {});

            // Get dialog elements after the dialog is shown
            const dialog = document.querySelector('.sidebar-dialog');
            const fileItems = dialog.querySelectorAll('.file-item');
            const confirmButton = dialog.querySelector('.confirm');
            const newFileButton = dialog.querySelector('.new-file-button');
            let selectedFileId = null;

            // Add click handlers for file selection
            fileItems.forEach(item => {
              item.addEventListener('click', () => {
                fileItems.forEach(f => f.classList.remove('selected'));
                item.classList.add('selected');
                selectedFileId = item.dataset.id;
                if (confirmButton) confirmButton.disabled = false;
              });

              item.addEventListener('dblclick', () => {
                if (item.dataset.id) {
                  handleFileSelection(item.dataset.id);
                }
              });
            });

            // Add click handler for new file button
            if (newFileButton) {
              newFileButton.addEventListener('click', handleFileCreation);
            }

            // Update confirm button handler
            if (confirmButton) {
              confirmButton.onclick = () => {
                if (selectedFileId) {
                  handleFileSelection(selectedFileId);
                }
              };
            }
          })
          .withFailureHandler((error) => {
            const errorContent = `
              <h2>Error</h2>
              <p>Failed to list todo files: ${error}</p>
              <div class="buttons">
                <button class="confirm" autofocus>OK</button>
              </div>
            `;
            showDialog(errorContent, () => {});
          })
          .listTodoFiles();
      }

       // automatically save waiting for 'saveTimeout' milliseconds
      let timeoutId;
      // Function to listen for keyboard input
      function listenForKeyboardInput() {
        document.addEventListener('keydown', resetTimer);
      }
      // Function to reset the timer
      function resetTimer() {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(saveTasks, saveTimeout);
      }

      function handleTaskClick(event, index) {
        const taskList = document.getElementById('taskList');
        const tasks = taskList.getElementsByClassName('task');
        const originalIndex = parseInt(tasks[index].dataset.originalIndex);

        if (event.detail === 2) {
          editTask(originalIndex);
        } else {
          if (event.ctrlKey) {
            tasks[index].classList.toggle('selected');
            if (selectedTasks.has(index)) {
              selectedTasks.delete(index);
            } else {
              selectedTasks.add(index);
            }
          } else if (event.shiftKey && lastSelectedIndex !== -1) {
            const start = Math.min(lastSelectedIndex, index);
            const end = Math.max(lastSelectedIndex, index);
            for (let i = start; i <= end; i++) {
              tasks[i].classList.add('selected');
              selectedTasks.add(i);
            }
          } else {
            Array.from(tasks).forEach(task => task.classList.remove('selected'));
            tasks[index].classList.add('selected');
            selectedTasks.clear();
            selectedTasks.add(index);
          }
          lastSelectedIndex = index;
        }
      }

      function handleKeyDown(event) {
        if (currentSortState !== 'file' && 
            ((event.ctrlKey && (event.key === 'ArrowUp' || event.key === 'ArrowDown')) ||
            (event.ctrlKey && (event.key.toLowerCase() === 'x' || event.key.toLowerCase() === 'v')))) {
          return;
        }
        
        if (document.activeElement === document.getElementById('searchBox') || 
            document.getElementById('dialogContainer').innerHTML !== '') {
          return;
        }

        const taskList = document.getElementById('taskList');
        const tasks = taskList.getElementsByClassName('task');
        
        if (lastSelectedIndex === -1) return;

        if (event.ctrlKey && event.key.toLowerCase() === 'x') {
          event.preventDefault();
          // Get all selected task indices in reverse order (to remove from end to start)
          const originalIndices = getOriginalIndices().sort((a, b) => b - a);
          
          // Clear previous cut tasks
          cutTasks = [];
          
          // Store the tasks that are being cut in original order
          originalIndices.reverse().forEach(index => {
            cutTasks.push({...allTasks[index]});
          });
          
          // Remove the cut tasks from allTasks (still in reverse order for proper splicing)
          originalIndices.forEach(index => {
            allTasks.splice(index, 1);
          });
          
          // Update display
          applyFilters();
        }

        if (event.ctrlKey && event.key.toLowerCase() === 'v') {
          event.preventDefault();
          
          if (cutTasks.length > 0) {
            // Get the current selected task's original index
            let insertIndex;
            if (lastSelectedIndex >= 0 && lastSelectedIndex < filteredTasks.length) {
              insertIndex = filteredTasks[lastSelectedIndex].originalIndex; // Insert before current selection
            } else {
              insertIndex = allTasks.length; // If no selection, append to end
            }
            
            // Insert all cut tasks at the insertion point in original order
            cutTasks.forEach((task) => {
              allTasks.splice(insertIndex++, 0, {...task});
            });
            
            // Reapply filters to update the display
            applyFilters();
          }
        }        

        if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {
          const taskList = document.getElementById('taskList');
          const tasks = taskList.getElementsByClassName('task');
          const selectedTask = tasks[lastSelectedIndex];
          
          if (selectedTask) {
            const rect = selectedTask.getBoundingClientRect();
            const viewHeight = window.innerHeight;
            
            // Get distance from top/bottom of viewport in number of tasks
            const tasksFromTop = Math.floor(rect.top / rect.height);
            const tasksFromBottom = Math.floor((viewHeight - rect.bottom) / rect.height);
            
            // Only prevent default scrolling if we're not near the edges
            if (event.key === 'ArrowUp' && tasksFromTop > 5 || 
                event.key === 'ArrowDown' && tasksFromBottom > 5) {
              event.preventDefault();
            }
          }

          if (event.key === 'ArrowUp') {
            if (event.ctrlKey && lastSelectedIndex > 0) {
              swapTasks(lastSelectedIndex, lastSelectedIndex - 1);
            } else if (event.altKey) {
              const selectedTaskObjects = getOriginalIndices().map(i => allTasks[i]);
              changePriority(selectedTaskObjects, true);
              applyFilters();
              const taskList = document.getElementById('taskList');
              const tasks = taskList.getElementsByClassName('task');
              selectedTasks.forEach(index => {
                tasks[index].classList.add('selected');
              });
            } else if (lastSelectedIndex > 0) {
              if (event.shiftKey) {
                // If shift is pressed, toggle selection of the previous task
                const newIndex = lastSelectedIndex - 1;
                if (selectedTasks.has(newIndex)) {
                  tasks[lastSelectedIndex].classList.remove('selected');
                  selectedTasks.delete(lastSelectedIndex);
                } else {
                  tasks[newIndex].classList.add('selected');
                  selectedTasks.add(newIndex);
                }
                lastSelectedIndex = newIndex;
              } else {
                // If no shift, clear all selections and select only the new task
                Array.from(tasks).forEach(task => task.classList.remove('selected'));
                lastSelectedIndex--;
                tasks[lastSelectedIndex].classList.add('selected');
                selectedTasks.clear();
                selectedTasks.add(lastSelectedIndex);
              }
            }
          } else if (event.key === 'ArrowDown') {
            if (event.ctrlKey && lastSelectedIndex < tasks.length - 1) {
              swapTasks(lastSelectedIndex, lastSelectedIndex + 1);
            } else if (event.altKey) {
              const selectedTaskObjects = getOriginalIndices().map(i => allTasks[i]);
              changePriority(selectedTaskObjects, false);
              applyFilters();
              const taskList = document.getElementById('taskList');
              const tasks = taskList.getElementsByClassName('task');
              selectedTasks.forEach(index => {
                tasks[index].classList.add('selected');
              });
            } else if (lastSelectedIndex < tasks.length - 1) {
              if (event.shiftKey) {
                // If shift is pressed, toggle selection of the next task
                const newIndex = lastSelectedIndex + 1;
                if (selectedTasks.has(newIndex)) {
                  tasks[lastSelectedIndex].classList.remove('selected');
                  selectedTasks.delete(lastSelectedIndex);
                } else {
                  tasks[newIndex].classList.add('selected');
                  selectedTasks.add(newIndex);
                }
                lastSelectedIndex = newIndex;
              } else {
                // If no shift, clear all selections and select only the new task
                Array.from(tasks).forEach(task => task.classList.remove('selected'));
                lastSelectedIndex++;
                tasks[lastSelectedIndex].classList.add('selected');
                selectedTasks.clear();
                selectedTasks.add(lastSelectedIndex);
              }
            }
          }
        } else if (event.key === ' ') {
          event.preventDefault();
          const selectedTask = tasks[lastSelectedIndex];
          if (selectedTask) {
            const originalIndex = parseInt(selectedTask.dataset.originalIndex);
            editTask(originalIndex);
          }
        } else if (event.ctrlKey && event.key.toLowerCase() ==='a') {
          event.preventDefault();
          const tasks = document.getElementsByClassName('task');
          Array.from(tasks).forEach((task, index) => {
            task.classList.add('selected');
            selectedTasks.add(index);
          });
          lastSelectedIndex = tasks.length - 1;
        } else if (event.key.toLowerCase() ==='c' && event.ctrlKey) {
          copySelectedTasks();
        } else if (event.key.toLowerCase() ==='c' && !event.ctrlKey) {
          cycleCompleteState();
        } else if (event.ctrlKey && event.altKey && event.key >= '1' && event.key <= '9') {
          saveFilterSet(event.key);
        } else if (event.key >= '1' && event.key <= '9') {
          loadFilterSet(event.key);
        } else if (!event.ctrlKey && event.key.toLowerCase() ==='x') {
          const selectedTaskObjects = getOriginalIndices().map(i => allTasks[i]);
          toggleCompletion(selectedTaskObjects);
          applyFilters();
          const taskList = document.getElementById('taskList');
          const tasks = taskList.getElementsByClassName('task');
          selectedTasks.forEach(index => {
            tasks[index].classList.add('selected');
          });
        } else if (event.key === 'Delete') {
          event.preventDefault();
          deleteTask(filteredTasks[lastSelectedIndex].originalIndex);
        } else if (!event.ctrlKey && event.key.toLowerCase() ==='f') {
          event.preventDefault();
          document.getElementById('searchBox').focus();
          return;
        } else if (event.key === '?') {
          event.preventDefault();
          showHelpWindow();
        } else if (event.key === '(') {
          addNewTask();
        } else if (event.key.toLowerCase() === 'q') {
          event.preventDefault();
          cyclePriorityState();
        } else if (event.key.toLowerCase() ==='s') {
          event.preventDefault();
          setDateForSelectedTasks();
        } else if (event.key.toLowerCase() ==='t') {
          event.preventDefault();
          cycleSortState();
        } else if (event.key.toLowerCase() ==='p') {
          event.preventDefault();
          setPriorityForSelectedTasks();
        } else if (event.key.toLowerCase() ==='d') {
          event.preventDefault();
          postponeSelectedTasks();
        } else if (event.key.toLowerCase() ==='u') {
          event.preventDefault();
          cycleDueState();
        } else if (event.key.toLowerCase() ==='0') {
          event.preventDefault();
          clearFilters();
        }
      }

      function showHelpWindow() {
        // Use google.script.run to call the server-side function
        google.script.run
          .withSuccessHandler(function(helpContent) {
            const htmlContent = `
              <div class="help-content">
                ${helpContent}
              </div>
            `;
            showDialog(htmlContent, () => {});
          })
          .withFailureHandler(function(error) {
            alert('Failed to load help content. Please try again.');
          })
          .getHelpContent();
      }

      // Start listening for keyboard input
      listenForKeyboardInput();

	    // Add this line to focus the page on load
	    window.onload = () => document.body.focus();

      document.addEventListener('DOMContentLoaded', function() {
        google.script.run
          .withSuccessHandler(function(result) {
            lastModifiedTime = result.lastModified;
            lastSavedTime = result.lastModified;
            
            // Store tasks but don't display them yet
            allTasks = result.tasks;
            generateContextButtons();
            
            // Load filter sets and then display tasks
            google.script.run
              .withSuccessHandler(function(filterSets) {
                allFilterSets = filterSets || {};
                if (filterSets['1']) {
                  loadFilterSet('1');  // This will trigger applyFilters()
                } else {
                  // If no filter set 1, then apply default display
                  applyFilters();
                }
              })
              .getAllFilterSets();
          })
          .getTasksAndModifiedTime();
      });

      document.addEventListener('keydown', handleKeyDown);    
	  
	    // Add this line to focus the page on load
	    window.onload = () => document.body.focus();

    </script>
  </body>
</html>
